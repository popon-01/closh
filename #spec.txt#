-- 内容 --
(a) Schemeサブセット(Mini-Scheme)の機能全部を実装すること．ただしTCOは省いてよい．
(b) ホスト言語（実装するための言語）の関数やオブジェクトをMini-Scheme内から利用できるようにすること
(c) [オプション] ホスト言語側のプログラムからMini-Schemeの関数を呼び出せるようにすること
(d) [オプション] その他面白そうな言語機構

・構文に合致しない入力はエラーとすること．
・実行時エラーによって処理系自体が停止してしまわないようにすること(できる範囲で)．


-- Mini-Scheme --
A. 構文

非終端記号:
大文字[A-Z]で始まる名前

終端記号:
開き括弧 (
閉じ括弧 )
ピリオド .
小文字[a-z]で構成される名前
シングルクオート ' で囲まれた文字列

X*  要素Xの0個以上のくりかえし
X+  要素Xの1個以上のくりかえし
[X] 要素Xは高々1個

Toplevel ::= Exp
    | Define
    | (load String)                      ファイルの内容を読み込む

Define ::= (define Id Exp)
  | (define (Id Id* [. Id]) Body)

Exp ::= Const                                   定数
| Id                                      変数
| (lambda Arg Body)                       λ抽象
| (Exp Exp*)                              関数適用
| (quote S-Exp)                           クオート (注1)
| (set! Id Exp)                           代入
| (let [Id] Bindings Body)                let
| (let* Bindings Body)                    let* (注4)
| (letrec Bindings Body)                  letrec
| (if Exp Exp [Exp])                      条件式(if)
| (cond (Exp Exp+)* [(else Exp+)])        条件式(cond) (注5)
| (and Exp*)                              条件式(and)
| (or Exp*)                               条件式(or)
| (begin Exp*)                            逐次実行
| (do ((Id Exp Exp)*) (Exp Exp*) Body)    繰り返し

Body ::= Define* Exp+

Arg ::= Id
| (Id* [Id . Id])

Bindings ::= ((Id Exp)*)

S-Exp ::= Const
| Id
| (S-Exp* [S-Exp . S-Exp])

Const ::= Num
| Bool
| String
| ()

Num: 最低限10進整数はサポートすること

Bool ::= '#t'
| '#f'

String: ダブルクオートで囲まれた文字列 (注1)

Id ::= [0-9A-Za-z!$%&*+-./<=>?@^_]+'   (注3)

(注1) (quote X) だけでなく 'X という記法もサポートすること．
(注2) バックスラッシュ \ によるエスケープをサポートすること．
(注3) 数値となるものをのぞくこと．
(注4) let* は let の0個以上の繰り返しではなく let* という名前である．
(注5) 節は(else節を含めて)最低1個はあること．else節は高々1個とすること．

B. 関数（最低限）

整数
number?, +, -, *, /, =, <, <=, >, >=

リスト
null?, pair?, list?, symbol?,
car, cdr, cons, list, length, memq, last, append,
set-car!, set-cdr!

ブール値
boolean?, not

文字列
string?, string-append,
symbol->string, string->symbol, string->number, number->string

関数
procedure?

比較
eq?, neq?, equal?

その他
load

C. 末尾呼び出し最適化(TCO)

D. Common-Lisp風マクロ

-- 方針 --
tokenize : Done
-> read (リードマクロの展開とリストへの整形) : Done
-> macro-expand
-> syntax-check (コード実行部を描きやすい形に整形するかも)
-> eval
-> print

lambda set! if and or begin -> special form
let letrec do -> ?
let* cond -> macro?


(defmacro let* (binds &body body)
  (if (null binds)
      `(begin ,@body)
      `(let (,(car binds)) (let* ,(cdr binds) ,@body))))

else -> #t に置き換え 
(defmacro cond (&body clauses)
  (if (null (cdr clauses))
      `(if ,(car (first clauses))
           (begin ,@(cdr (first clauses))))
      `(if ,(car (first clauses))
           (begin ,@(cdr (first clauses)))
           (cond (cdr clauses)))))

